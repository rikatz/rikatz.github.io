<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kubernetes on The Katz Experiments</title><link>https://www.rkatz.xyz/tags/kubernetes/</link><description>Recent content in Kubernetes on The Katz Experiments</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 16 Apr 2021 16:32:27 -0300</lastBuildDate><atom:link href="https://www.rkatz.xyz/tags/kubernetes/index.xml" rel="self" type="application/rss+xml"/><item><title>Using Falco to monitor outbound traffic for Pods in Kubernetes</title><link>https://www.rkatz.xyz/post/2021-04-16-falco-network-monitoring/</link><pubDate>Fri, 16 Apr 2021 16:32:27 -0300</pubDate><guid>https://www.rkatz.xyz/post/2021-04-16-falco-network-monitoring/</guid><description>
&lt;h1 id="using-falco-to-monitor-outbound-traffic-for-pods-in-kubernetes">Using Falco to monitor outbound traffic for Pods in Kubernetes&lt;/h1>
&lt;p>&lt;a href="https://www.falco.org">Falco&lt;/a> is an opensource project from &lt;a href="https://sysdig.com/">Sysdig&lt;/a> focused on container runtime and cloud native security, that uses modern technologies like &lt;a href="https://ebpf.io">eBPF&lt;/a> to monitor environment situations using &lt;a href="https://man7.org/linux/man-pages/man2/syscalls.2.html">syscalls&lt;/a> and other &lt;a href="https://falco.org/docs/event-sources/">events sources&lt;/a>&lt;/p>
&lt;p>We&amp;rsquo;ve used Falco some time ago as a PoC to monitor some specific events, and recently I&amp;rsquo;ve started to mess with it a bit to help contributing on it as a request from the amazing &lt;a href="https://twitter.com/danpopnyc/">Dan Pop&lt;/a> and also to understand better how Falco could help me in future situations.&lt;/p>
&lt;h2 id="the-problem-i-needed-to-solve">The problem I needed to solve&lt;/h2>
&lt;p>Who uses Kubernetes knows how hard is to keep track of networking connections originated from Pods. Even using &lt;a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/">Network Policies&lt;/a>, it&amp;rsquo;s hard to assess which Pod tried to open a connection to internal or external world.&lt;/p>
&lt;p>Having this kind of information is essential in environments with a higher restriction level, or even if you need to legally answer &amp;ldquo;who was connecting to this network endpoint&amp;rdquo;.&lt;/p>
&lt;p>Some CNI providers have specific solutions, like &lt;a href="https://antrea.io">Antrea&lt;/a> exporting via &lt;a href="https://antrea.io/docs/v1.0.0/network-flow-visibility/">Netflow&lt;/a>, or &lt;a href="https://cilium.io/">Cilium&lt;/a> with a short retention solution and visualization with project &lt;a href="https://github.com/cilium/hubble">Hubble&lt;/a>.&lt;/p>
&lt;p>But I wanted something more: I wanted a solution that could be applied with any CNI, even if it does not support Network Policy. I don&amp;rsquo;t care if the connection was dropped or not, I wanted to know how to monitor every connection attempt my Pods does. And this can be monitored, as every connection generates a syscall.&lt;/p>
&lt;h2 id="the-final-result">The final result&lt;/h2>
&lt;p>&lt;img src="https://www.rkatz.xyz/images/falcomonitoring/grafana.png" alt="Final result">&lt;/p>
&lt;h2 id="let-me-introduce-you-falco">Let me introduce you Falco!&lt;/h2>
&lt;p>As I&amp;rsquo;ve explained before, Falco is an opensource project that monitors events in servers. Those events can be syscalls from containers, or even Kubernetes audit events.&lt;/p>
&lt;p>Falco is based in &lt;a href="https://falco.org/docs/rules/">rules&lt;/a>. Those rules mainly define:&lt;/p>
&lt;ul>
&lt;li>a common &lt;strong>name&lt;/strong> (&lt;code>rule&lt;/code>) - &amp;ldquo;Unauthorized SSH access&amp;rdquo;&lt;/li>
&lt;li>a &lt;strong>description&lt;/strong> (&lt;code>desc&lt;/code>) - &amp;ldquo;Some user attempted to login in an SSH service&amp;rdquo;&lt;/li>
&lt;li>a &lt;strong>priority&lt;/strong> (&lt;code>priority&lt;/code>) - &amp;ldquo;WARNING&amp;rdquo;&lt;/li>
&lt;li>a &lt;strong>detailed output&lt;/strong> from the event (&lt;code>output&lt;/code>) - &amp;ldquo;Server &amp;lsquo;homer&amp;rsquo; received a connectin in port 22 from the non authorized IP 192.168.0.123&amp;rdquo;&lt;/li>
&lt;li>a &lt;strong>condition&lt;/strong> (&lt;code>cond&lt;/code>) - &amp;ldquo;(Server has the word &amp;lsquo;restricted&amp;rsquo; in the hostname, and receives a connection in port 22 from a source that is not network 10.10.10.0/24) OR (server received a connection in port 22 mas the process that received this connection is not called &amp;lsquo;sshd&amp;rsquo;)&lt;/li>
&lt;/ul>
&lt;p>Here, I need to point something: I wrote the condition field above in a really simple form, as a common language. Besides Falco rules not being written exactly in this form (as we will see below), it&amp;rsquo;s a really similar format, making it easier to read the rules.&lt;/p>
&lt;p>The rules can also contain other fields not explained here, like exceptions, aditional tags, and also &lt;strong>lists&lt;/strong> and &lt;strong>macros&lt;/strong> that turns repetition of strings easier.&lt;/p>
&lt;h2 id="installing-falco">Installing Falco&lt;/h2>
&lt;p>Before we begin to install Falco, a brief description of my environment:&lt;/p>
&lt;ul>
&lt;li>3 virtual servers with &lt;a href="https://kinvolk.io/flatcar-container-linux/">Flatcar Linux&lt;/a> 2765.2.2, because I LOVE FLATCAR MODEL!! (and also it has an up to date Kernel, which allows me to use Falco eBPF driver). If you want to learn how to install Flatcar in 5 minutes using VMware Player, there&amp;rsquo;s a blog post &lt;a href="https://www.rkatz.xyz/post/2020-09-13-flatcar/">here&lt;/a> explaining how.&lt;/li>
&lt;li>My physical networking is &lt;code>192.168.0.0/24&lt;/code>&lt;/li>
&lt;li>My Kubernetes install is v1.21.0 via Kubeadm. Pods are creted in network &lt;code>172.16.0.0/16&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>To install Falco on Kubernetes using &lt;a href="http://helm.sh">helm&lt;/a>, basically you need to follow 4 steps:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>kubectl create ns falco
&lt;span class="ln">2&lt;/span>helm repo add falcosecurity https://falcosecurity.github.io/charts
&lt;span class="ln">3&lt;/span>helm repo update
&lt;span class="ln">4&lt;/span>helm install falco falcosecurity/falco --namespace falco --set falcosidekick.enabled&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span> --set falcosidekick.webui.enabled&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span> --set ebpf.enabled&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After that, you just need to verify if all Pods in namespace &lt;code>falco&lt;/code> are running, with &lt;code>kubectl get pods -n falco&lt;/code>&lt;/p>
&lt;p>With this install, I&amp;rsquo;ve also enabled &lt;a href="https://github.com/falcosecurity/falcosidekick">sidekick&lt;/a> which is a really cool project that exports Falco events to a bunch of outputs, and also allows you to visualize them in its own interface&lt;/p>
&lt;h2 id="creating-and-visualizing-alerts">Creating and visualizing alerts&lt;/h2>
&lt;p>Falco has some default rules. As an example, as soon as it is executing, if you issue a &lt;code>kubectl exec -it&lt;/code> to a Pod, it will generate some alert:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>kubectl &lt;span class="nb">exec&lt;/span> -it -n testkatz nginx-6799fc88d8-996gz -- /bin/bash
&lt;span class="ln">2&lt;/span>root@nginx-6799fc88d8-996gz:/#
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And in Falco logs (I&amp;rsquo;ve made this JSON clearer, but it&amp;rsquo;s a one liner)&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="ln"> 1&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="nt">&amp;#34;output&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;14:23:15.139384666: Notice A shell was spawned in a container with an attached terminal (user=root user_loginuid=-1 k8s.ns=testkatz k8s.pod=nginx-6799fc88d8-996gz container=3db00b476ee2 shell=bash parent=runc cmdline=bash terminal=34816 container_id=3db00b476ee2 image=nginx) k8s.ns=testkatz k8s.pod=nginx-6799fc88d8-996gz container=3db00b476ee2&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="nt">&amp;#34;priority&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;Notice&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="nt">&amp;#34;rule&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;Terminal shell in container&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="nt">&amp;#34;time&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;2021-04-16T14:23:15.139384666Z&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="nt">&amp;#34;output_fields&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="nt">&amp;#34;container.id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;3db00b476ee2&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="nt">&amp;#34;container.image.repository&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;nginx&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="nt">&amp;#34;evt.time&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">1618582995139384666&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="nt">&amp;#34;k8s.ns.name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;testkatz&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="nt">&amp;#34;k8s.pod.name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;nginx-6799fc88d8-996gz&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="nt">&amp;#34;proc.cmdline&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;bash&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="nt">&amp;#34;proc.name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;bash&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="nt">&amp;#34;proc.pname&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;runc&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="nt">&amp;#34;proc.tty&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">34816&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="nt">&amp;#34;user.loginuid&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">-1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln">17&lt;/span> &lt;span class="nt">&amp;#34;user.name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;root&amp;#34;&lt;/span>
&lt;span class="ln">18&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">19&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In this log you can check that besides the output message, some additional fields are mapped, like the process name, the namespace and the pod name. We will explore this further.&lt;/p>
&lt;h2 id="creating-rules-for-falco">Creating rules for Falco&lt;/h2>
&lt;p>Falco can monitor syscalls. A syscall of a network connection is of the &amp;lsquo;connect&amp;rsquo; type, and this way, we can create a basic rule so Falco can always generate a notification when some container tries to connect to the outside world.&lt;/p>
&lt;p>Falco already comes with a pre defined list and macro for outbound connections:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="ln"> 1&lt;/span>&lt;span class="c"># RFC1918 addresses were assigned for private network usage&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">list&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">rfc_1918_addresses&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">items&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;&amp;#34;10.0.0.0/8&amp;#34;&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;&amp;#34;172.16.0.0/12&amp;#34;&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;&amp;#34;192.168.0.0/16&amp;#34;&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">macro&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">outbound&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">condition&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="sd"> (((evt.type = connect and evt.dir=&amp;lt;) or
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="sd"> (evt.type in (sendto,sendmsg) and evt.dir=&amp;lt; and
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="sd"> fd.l4proto != tcp and fd.connected=false and fd.name_changed=true)) and
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="sd"> (fd.typechar = 4 or fd.typechar = 6) and
&lt;/span>&lt;span class="ln">11&lt;/span>&lt;span class="sd"> (fd.ip != &amp;#34;0.0.0.0&amp;#34; and fd.net != &amp;#34;127.0.0.0/8&amp;#34; and not fd.snet in (rfc_1918_addresses)) and
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="sd"> (evt.rawres &amp;gt;= 0 or evt.res = EINPROGRESS))&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This macro:&lt;/p>
&lt;ul>
&lt;li>Verifies if the event is of type connect (network connection) and it&amp;rsquo;s outbound (&lt;code>evt.dir=&amp;lt;&lt;/code>)&lt;/li>
&lt;li>OR if this is a sendto or sendmsg type going outbound, which protocol is not TCP and the file descriptor is not connected, and the name does not change, tipically an UDP connection.&lt;/li>
&lt;li>If any of the conditions above are true AND the file descriptor is 4 or 6, which represents IPv4 or IPv6&lt;/li>
&lt;li>AND the IP is not equal to 0.0.0.0 AND the network is not equal to 127.0.0.0/8 (localhost) AND the destination network (&lt;code>fd.snet&lt;/code>) is not in list &lt;code>rfc_1918_addresses&lt;/code>&lt;/li>
&lt;li>AND the return from the event is bigger than 0 OR is INPROGRESS&lt;/li>
&lt;/ul>
&lt;p>If you put this expression in vscode, you can work through the openning and closure of parenthisis. All existing fields are really well explained in &lt;a href="https://falco.org/docs/rules/supported-fields">supported fields&lt;/a>&lt;/p>
&lt;p>But the above macro does not fits our needs, as it ignores the outbound connections to internal networks (rfc1918), which is the majority of enterprise cases. Let&amp;rsquo;s define then our own macro and rule:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="ln"> 1&lt;/span>- &lt;span class="nt">macro&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">outbound_corp&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">condition&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">&amp;gt;&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="sd"> (((evt.type = connect and evt.dir=&amp;lt;) or
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="sd"> (evt.type in (sendto,sendmsg) and evt.dir=&amp;lt; and
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="sd"> fd.l4proto != tcp and fd.connected=false and fd.name_changed=true)) and
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="sd"> (fd.typechar = 4 or fd.typechar = 6) and
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="sd"> (fd.ip != &amp;#34;0.0.0.0&amp;#34; and fd.net != &amp;#34;127.0.0.0/8&amp;#34;) and
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="sd"> (evt.rawres &amp;gt;= 0 or evt.res = EINPROGRESS))&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">list&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">k8s_not_monitored&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">11&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">items&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;&amp;#34;green&amp;#34;&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;&amp;#34;blue&amp;#34;&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="w">&lt;/span>- &lt;span class="nt">rule&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kubernetes outbound connection&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">14&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">desc&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">A pod in namespace attempted to connect to the outer world&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">15&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">condition&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">outbound_corp and k8s.ns.name != &amp;#34;&amp;#34; and not k8s.ns.label.network in (k8s_not_monitored)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">16&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">output&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;Outbound network traffic connection from a Pod: (pod=%k8s.pod.name namespace=%k8s.ns.name srcip=%fd.cip dstip=%fd.sip dstport=%fd.sport proto=%fd.l4proto procname=%proc.name)&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln">17&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">priority&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">WARNING&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The rule above:&lt;/p>
&lt;ul>
&lt;li>Creates a macro &lt;code>outbound_corp&lt;/code> that deals with any outbound connection&lt;/li>
&lt;li>Creates a list &lt;code>k8s_not_monitored&lt;/code> with values &lt;code>blue&lt;/code> and &lt;code>green&lt;/code>&lt;/li>
&lt;li>Creates a rule that verifies:
&lt;ul>
&lt;li>If it&amp;rsquo;s an outbound traffic defined in macro &lt;code>outbound_corp&lt;/code>&lt;/li>
&lt;li>AND If the field k8s.ns.name is defined (which means it&amp;rsquo;s being executed inside Kubernetes)&lt;/li>
&lt;li>And if the namespace containing the Pod does not have a label &lt;code>network&lt;/code> containing any of the values in list &lt;code>k8s_not_monitored&lt;/code>. If it does, the traffic wont be monitored&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>When this rule is triggered, the following output might be seen:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>Outbound network traffic connection from a Pod: (pod=nginx namespace=testkatz srcip=172.16.204.12 dstip=192.168.0.1 dstport=80 proto=tcp procname=curl)
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="applying-the-rules">Applying the rules&lt;/h2>
&lt;p>Helm chart allows us to install &lt;a href="https://github.com/falcosecurity/charts/tree/master/falco#loading-custom-rules">custom rules&lt;/a> without much effort.&lt;/p>
&lt;p>To do so, we need to pick the rules above and put inside a &lt;code>customRules&lt;/code> structure, before &amp;lsquo;upgrading&amp;rsquo; the installation:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="ln"> 1&lt;/span>&lt;span class="nt">customRules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="ln"> 2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">rules-networking.yaml&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">|-&lt;/span>&lt;span class="sd">
&lt;/span>&lt;span class="ln"> 3&lt;/span>&lt;span class="sd"> - macro: outbound_corp
&lt;/span>&lt;span class="ln"> 4&lt;/span>&lt;span class="sd"> condition: &amp;gt;
&lt;/span>&lt;span class="ln"> 5&lt;/span>&lt;span class="sd"> (((evt.type = connect and evt.dir=&amp;lt;) or
&lt;/span>&lt;span class="ln"> 6&lt;/span>&lt;span class="sd"> (evt.type in (sendto,sendmsg) and evt.dir=&amp;lt; and
&lt;/span>&lt;span class="ln"> 7&lt;/span>&lt;span class="sd"> fd.l4proto != tcp and fd.connected=false and fd.name_changed=true)) and
&lt;/span>&lt;span class="ln"> 8&lt;/span>&lt;span class="sd"> (fd.typechar = 4 or fd.typechar = 6) and
&lt;/span>&lt;span class="ln"> 9&lt;/span>&lt;span class="sd"> (fd.ip != &amp;#34;0.0.0.0&amp;#34; and fd.net != &amp;#34;127.0.0.0/8&amp;#34;) and
&lt;/span>&lt;span class="ln">10&lt;/span>&lt;span class="sd"> (evt.rawres &amp;gt;= 0 or evt.res = EINPROGRESS))
&lt;/span>&lt;span class="ln">11&lt;/span>&lt;span class="sd"> - list: k8s_not_monitored
&lt;/span>&lt;span class="ln">12&lt;/span>&lt;span class="sd"> items: [&amp;#39;&amp;#34;green&amp;#34;&amp;#39;, &amp;#39;&amp;#34;blue&amp;#34;&amp;#39;]
&lt;/span>&lt;span class="ln">13&lt;/span>&lt;span class="sd"> - rule: kubernetes outbound connection
&lt;/span>&lt;span class="ln">14&lt;/span>&lt;span class="sd"> desc: A pod in namespace attempted to connect to the outer world
&lt;/span>&lt;span class="ln">15&lt;/span>&lt;span class="sd"> condition: outbound_corp and k8s.ns.name != &amp;#34;&amp;#34; and not k8s.ns.label.network in (k8s_not_monitored)
&lt;/span>&lt;span class="ln">16&lt;/span>&lt;span class="sd"> output: &amp;#34;Outbound network traffic connection from a Pod: (pod=%k8s.pod.name namespace=%k8s.ns.name srcip=%fd.cip dstip=%fd.sip dstport=%fd.sport proto=%fd.l4proto procname=%proc.name)&amp;#34;
&lt;/span>&lt;span class="ln">17&lt;/span>&lt;span class="sd"> priority: WARNING&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>It&amp;rsquo;s the same rule as above, but inside a &lt;code>customRules.rules-networking.yaml&lt;/code> field.&lt;/p>
&lt;p>After that we just need to update Falco installation, with the following:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>helm upgrade falco falcosecurity/falco --namespace falco --set falcosidekick.enabled=true --set falcosidekick.webui.enabled=true --set ebpf.enabled=true -f custom-rules.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Falco Pods will be restarted. If the Pod enters in an &lt;code>Error&lt;/code> state, take a look into their logs to see if there&amp;rsquo;s some failure on rules (yaml = space problems!)&lt;/p>
&lt;h2 id="show-me-the-logs">Show me the logs!!!&lt;/h2>
&lt;p>Executing &lt;code>kubectl logs -n falco -l app=falco&lt;/code> we will see our outbound connection logs appearing:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="ln"> 1&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="ln"> 2&lt;/span> &lt;span class="nt">&amp;#34;output&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;18:05:13.045457220: Warning Outbound network traffic connection from a Pod: (pod=falco-l8xmm namespace=falco srcip=192.168.0.150 dstip=192.168.0.11 dstport=2801 proto=tcp procname=falco) k8s.ns=falco k8s.pod=falco-l8xmm container=cb86ca8afdaa&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln"> 3&lt;/span> &lt;span class="nt">&amp;#34;priority&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;Warning&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="nt">&amp;#34;rule&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;kubernetes outbound connection&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="nt">&amp;#34;time&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;2021-04-16T18:05:13.045457220Z&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="nt">&amp;#34;output_fields&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="nt">&amp;#34;container.id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;cb86ca8afdaa&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="nt">&amp;#34;evt.time&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">1618596313045457220&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="nt">&amp;#34;fd.cip&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;192.168.0.150&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="nt">&amp;#34;fd.l4proto&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;tcp&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="nt">&amp;#34;fd.sip&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;192.168.0.11&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="nt">&amp;#34;fd.sport&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">2801&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="nt">&amp;#34;k8s.ns.name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;falco&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="ln">15&lt;/span> &lt;span class="nt">&amp;#34;k8s.pod.name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="s2">&amp;#34;falco-l8xmm&amp;#34;&lt;/span>
&lt;span class="ln">16&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">17&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>But those are logs generated by the own Falco containers, and we don&amp;rsquo;t want them. Let&amp;rsquo;s mark this namespace with the label that will make it stop generating the logs from those Pods traffic:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="ln">1&lt;/span>kubectl label ns falco &lt;span class="nv">network&lt;/span>&lt;span class="o">=&lt;/span>green
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Nice! Now that Falco Pods does not enter anymore in monitoring, let&amp;rsquo;s make some tests :D For that, I&amp;rsquo;ve created a namespace called &lt;code>testkatz&lt;/code> with some Pods inside, and then I&amp;rsquo;ve started to generate some outbound traffic:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>&amp;#34;output&amp;#34;:&amp;#34;18:11:04.365837060: Warning Outbound network traffic connection from a Pod: (pod=nginx-6799fc88d8-996gz namespace=testkatz srcip=172.16.166.174 dstip=10.96.0.10 dstport=53 proto=udp procname=curl)
&lt;span class="ln">2&lt;/span>=====
&lt;span class="ln">3&lt;/span>&amp;#34;output&amp;#34;:&amp;#34;18:11:04.406290360: Warning Outbound network traffic connection from a Pod: (pod=nginx-6799fc88d8-996gz namespace=testkatz srcip=172.16.166.174 dstip=172.217.30.164 dstport=80 proto=tcp procname=curl)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the above log, we can see a call to the DNS, followed by a call to the destination server. We can see also which program inside the container started this traffic.&lt;/p>
&lt;h2 id="a-better-visualization">A better visualization&lt;/h2>
&lt;p>No one deserves to monitor by watching JSON logs streaming on the screen, right? Here comes Falco Sidekick to the rescue. It was installed with Falco, so we only need to configure it to send those &amp;ldquo;alerts&amp;rdquo; to a desired output.&lt;/p>
&lt;p>Sidekick comes with a web interface, that can be accesses with a port-forward, as example:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>kubectl port-forward -n falco pod/falco-falcosidekick-ui-764f5f469f-njppj 2802
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After that, you only need to access with your browser [http://localhost:2802/ui] and you will have something as cool as:&lt;/p>
&lt;p>&lt;img src="https://www.rkatz.xyz/images/falcomonitoring/sidekick1.png" alt="Sidekick Dashboard">&lt;/p>
&lt;p>&lt;img src="https://www.rkatz.xyz/images/falcomonitoring/sidekick2.png" alt="Sidekick Events">&lt;/p>
&lt;p>But I want to send this to a place where I can retain this, as some install of Grafana Loki. You can use the Grafana Cloud Freetier for this example, but do not use this in production if you have a lot of logs :)&lt;/p>
&lt;p>After generating a user and apikey in Grafana Cloud, you can update your Falco sidekick install with the following command (thanks Thomas Labarussias for the idea!):&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>helm upgrade falco falcosecurity/falco --namespace falco --set falcosidekick.enabled=true --set falcosidekick.webui.enabled=true --set ebpf.enabled=true --set falcosidekick.config.loki.hostport=https://USER:APIKEY@logs-prod-us-central1.grafana.net -f custom-rules.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Restart sidekick with &lt;code>kubectl delete pods -n falco -l app.kubernetes.io/name=falcosidekick&lt;/code> and you should see messages like &lt;code>[INFO] : Loki - Post OK (204)&lt;/code> in sidekick log each time a new alert is triggered.&lt;/p>
&lt;p>With that, you may have a dashboard in Grafana Cloud as I shown you on the beginning of this article :)&lt;/p>
&lt;p>&lt;a href="https://gist.github.com/rikatz/d53751acf9b705262db992b3bd98acbe#file-dashboard-json">Here&lt;/a> is my dashboard example, but remember to change your Loki datastore, and also if you have improved this dashboard please post its config and a picture to make me happy!&lt;/p></description></item><item><title>Kubernetes Control Plane natively on FreeBSD with K3s</title><link>https://www.rkatz.xyz/post/2020-12-30-k8s-control-plane-fbsd-k3s/</link><pubDate>Wed, 30 Dec 2020 17:55:19 -0300</pubDate><guid>https://www.rkatz.xyz/post/2020-12-30-k8s-control-plane-fbsd-k3s/</guid><description>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>I&amp;rsquo;ve been trying, on the past few days make Kubernetes usable on FreeBSD. Why? Some would say I like to suffer. Others would say I have much spare time.&lt;/p>
&lt;p>To be honest, I&amp;rsquo;m doing this for fun. &lt;a href="https://www.freebsd.org">FreeBSD&lt;/a>, for me, is one of the most stable and performant Operating Systems, and it&amp;rsquo;s sad that we cannot
use it to run Kubernetes components (yet).&lt;/p>
&lt;p>In a near future, me and &lt;a href="https://twitter.com/fuzzykb">Karen Bruner&lt;/a> are planning to make not only the control plane usable, but also to use one of the precedents of containers on
modern operating systems, even before Docker: &lt;a href="https://www.freebsd.org/doc/handbook/jails.html">Jails&lt;/a> as a &amp;ldquo;container runtime&amp;rdquo;.&lt;/p>
&lt;p>I&amp;rsquo;m also using &lt;a href="https://k3s.io/">k3s&lt;/a> because I became too lazy to configure Kubernetes the hard way :P So bootstrapping an etcd, then the components was too much (for now)
just to have some fun. But maybe some day, will do.&lt;/p>
&lt;p>&lt;strong>Spoiler alert&lt;/strong>: All the main components of Kubernetes can be compiled for FreeBSD. An exception, right now is just &lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/">kubelet&lt;/a>
that have, in a method a wrong syscall to fetch the node boottime, but a &lt;a href="https://github.com/kubernetes/kubernetes/pull/97270">PR&lt;/a> was created to correct that.&lt;/p>
&lt;h2 id="removing-code-before-compiling">Removing code before compiling&lt;/h2>
&lt;p>So K3s is a AIO (all in one) binary that runs all the components necessary to make Kubernetes works. You can use Alex Ellis &lt;a href="https://github.com/alexellis/k3sup">k3sup&lt;/a>
to bootstrap a Kubernetes cluster really, really fast.&lt;/p>
&lt;p>Karen has also shown &lt;a href="https://productionwithscissors.run/2020/12/26/adventures-in-freebernetes-tutorial-build-your-own-bare-vm-k3s-cluster/">how to do this with FreeBSD&lt;/a> as a virtualization host + Linux machines running over bhyve (It&amp;rsquo;s a FreeBSD + bhyve + Linux + k3sup) and you should really check this!&lt;/p>
&lt;p>But going back to the main subject: k3s does not natively compile for FreeBSD. And why this happens? Because it needs some components that can only be compiled on Linux (or Windows) to work.&lt;/p>
&lt;p>As an example, it embeds &lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy&lt;/a>. But, kube-proxy needs &lt;a href="https://en.wikipedia.org/wiki/Iptabl">iptables&lt;/a> and ipvs(&lt;a href="https://en.wikipedia.org/wiki/IP_Virtual_Server">https://en.wikipedia.org/wiki/IP_Virtual_Server&lt;/a>) to compile, which are Linux native technologies, not present on FreeBSD kernel.&lt;/p>
&lt;p>The same happens with &lt;a href="https://github.com/coreos/flannel">flannel&lt;/a>, which is embedded in the code and used as the &lt;a href="https://github.com/containernetworking/cni">CNI&lt;/a>.&lt;/p>
&lt;p>Fortunately, all of this code are present on a main package of k3s: &lt;strong>agent&lt;/strong>. But, we don&amp;rsquo;t need agent for our Control Plane, because agent is responsible for behaving like&amp;hellip;AN AGENT for k3s :D&lt;/p>
&lt;p>So, moving on, you can see the necessary modifications to make k3s compile for FreeBSD here: &lt;a href="https://github.com/k3s-io/k3s/compare/v1.20.0+k3s2...rikatz:fbsd-control-plane">https://github.com/k3s-io/k3s/compare/v1.20.0+k3s2...rikatz:fbsd-control-plane&lt;/a>&lt;/p>
&lt;p>Explaining:&lt;/p>
&lt;ul>
&lt;li>There are some files I hadn&amp;rsquo;t changed, but appear as difference because I&amp;rsquo;ve made all the mods from upstream branch&lt;/li>
&lt;li>On the &lt;code>main.go&lt;/code> files (cmd/k3s/main.go and main.go) the call to &amp;ldquo;agent&amp;rdquo; packages is removed. The resulting binary wont have &amp;ldquo;agent&amp;rdquo; subcommand, but only &amp;ldquo;server&amp;rdquo;, &amp;ldquo;kubectl&amp;rdquo;, etc.&lt;/li>
&lt;li>On &lt;code>pkg/cli/server/server.go&lt;/code> all the references for &lt;code>agent&lt;/code> and &lt;code>rootless&lt;/code> are removed. This way, we are not using anything from &lt;code>agent&lt;/code> package that can stop us from compiling!&lt;/li>
&lt;li>On &lt;code>pkg/daemons/executor&lt;/code> interface, all the references for Kubelet and KubeProxy are removed. We&amp;rsquo;re running control plane, and as both of those components does not compile in FreeBSD, let&amp;rsquo;s get rid of them&lt;/li>
&lt;li>On &lt;code>pkg/server/server.go&lt;/code> all the references for rootless/rootlessports are removed, because this package uses some native Linux calls to make rootless works (and we&amp;rsquo;re not running anything as a container anyway!)&lt;/li>
&lt;/ul>
&lt;p>There&amp;rsquo;s one more item to take note: On &lt;a href="https://github.com/rikatz/k3s/blob/fbsd-control-plane/pkg/cli/server/server.go#L47">server.go&lt;/a> k3s uses an artifact to masquerade its process to not expose some credential passed as an argument.&lt;/p>
&lt;p>But the library used (gspt) uses some headers and some sort of CGO, so you can make two choices here:&lt;/p>
&lt;ul>
&lt;li>Remove the mentioned line (and the referenced library) and be aware someone using ps wwwaux can see your credentials&lt;/li>
&lt;li>Keep the line, but compile on a FreeBSD machine (instead of using GOOS=freebsd on a Linux machine). Also, be aware that &lt;strong>WITH THIS OPTION K3S DOES NOT COMPILE FOR RPI3/ARM64&lt;/strong> (or maybe you need a rpi3 and compile there, which is plausible but I didn&amp;rsquo;t tried!)&lt;/li>
&lt;/ul>
&lt;p>One alternative here (and I need to check if this is possible) is to replace this to some syscall.&lt;/p>
&lt;h2 id="compiling">Compiling&lt;/h2>
&lt;p>So now that all the modifications have been explained, compiling is pretty easy:&lt;/p>
&lt;ul>
&lt;li>If you are on a Linux machine (and removed the gspt line mentioned above)&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>GOOS=freebsd go build -o k3s main.go
&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can put also a GOARCH=arm64 together with GOOS=freebsd and compile it for RPi3&lt;/p>
&lt;ul>
&lt;li>If you are on a FreeBSD machine:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>go build -o k3s main.go
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Aaaand that&amp;rsquo;s it!&lt;/p>
&lt;h2 id="running">Running&lt;/h2>
&lt;p>Well, so here we got a problem. K3s was built to run as a standalone AIO with embedded database (sqlite), or you can use an external database (postgres, mysql, etcd, etc).&lt;/p>
&lt;p>But, it happens that sqlite is built with CGO, and because we don&amp;rsquo;t have it on FreeBSD the best option FOR ME was: install a default Postgres and make it run.&lt;/p>
&lt;p>Here a side note: I didn&amp;rsquo;t put much effort on trying to make sqlite works, and instead I&amp;rsquo;ve directly jumped to Postgres because it was the easiest path. But, be my guest, and tell me what have you discovered!&lt;/p>
&lt;p>Well, so, to make it run we need:&lt;/p>
&lt;ul>
&lt;li>A Postgres DB&lt;/li>
&lt;li>The generated binary&lt;/li>
&lt;/ul>
&lt;p>Installing Postgres on FreeBSD is really, really simple but yes, you can run this on an external DB running on Linux, in some cloud, etc.&lt;/p>
&lt;p>But let&amp;rsquo;s install this DB. Assuming you have a FreeBSD box working:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>pkg update
&lt;span class="ln">2&lt;/span>pkg install postgresql12-server postgresql12-client
&lt;span class="ln">3&lt;/span>sysrc postgresql_enable=yes
&lt;span class="ln">4&lt;/span>/usr/local/etc/rc.d/postgresql initdb
&lt;span class="ln">5&lt;/span>service postgresql start
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And that&amp;rsquo;s it for PostgreSQL. Obviously, this is a VERY INSECURE lab setup! Don&amp;rsquo;t run this (or anything in this tutorial, to be fair) in Production!&lt;/p>
&lt;p>Well, with Postgres up and running, you can run k3s and your control plane will be magically bootstrapped:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>./k3s server --datastore-endpoint=postgres://postgres@127.0.0.1?sslmode=disable
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is going to print a lot of messages in your terminal, and now you have a Kubernetes Control Plane up and running natively on FreeBSD. Nice, right?&lt;/p>
&lt;h2 id="testing">Testing&lt;/h2>
&lt;p>Well, ok, the daemon is running but PROVE ME IT WORKS!&lt;/p>
&lt;p>Okie, so first of all, you need somewhere to run a kubectl. You can run it on FreeBSD (it&amp;rsquo;s easy to compile! I promise!) but I wont go that way right now.&lt;/p>
&lt;p>So, grab the kubeconfig you&amp;rsquo;re going to use on &lt;code>/var/lib/rancher/k3s/server/cred/admin.kubeconfig&lt;/code>, plus the referenced certificates in &lt;code>/var/lib/rancher/k3s/server/tls/client-*&lt;/code> and &lt;code>/var/lib/rancher/k3s/server/tls/server-ca.crt&lt;/code>, and copy them to another machine that kubectl is installed.&lt;/p>
&lt;p>Edit the admin.kubeconfig file, changing:&lt;/p>
&lt;ul>
&lt;li>&lt;code>server: https://127.0.0.1:6444&lt;/code> -&amp;gt; &lt;code>server: https://fbsd-ip:6443&lt;/code>&lt;/li>
&lt;li>&lt;code>certificate-authority&lt;/code>, &lt;code>client-certificate&lt;/code> and &lt;code>client-key&lt;/code> to point to certificates location. If they&amp;rsquo;re on the same directory as admin.kubeconfig, just remove the leading path and leave only the file name&lt;/li>
&lt;/ul>
&lt;p>Great! So now let&amp;rsquo;s check if kubectl can communicate with the server and what it brings to us:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>kubectl --kubeconfig=admin.kubeconfig version
&lt;span class="ln">2&lt;/span>Client Version: version.Info{Major:&amp;#34;1&amp;#34;, Minor:&amp;#34;20&amp;#34;, GitVersion:&amp;#34;v1.20.1&amp;#34;, GitCommit:&amp;#34;c4d752765b3bbac2237bf87cf0b1c2e307844666&amp;#34;, GitTreeState:&amp;#34;clean&amp;#34;, BuildDate:&amp;#34;2020-12-18T12:09:25Z&amp;#34;, GoVersion:&amp;#34;go1.15.5&amp;#34;, Compiler:&amp;#34;gc&amp;#34;, Platform:&amp;#34;linux/amd64&amp;#34;}
&lt;span class="ln">3&lt;/span>Server Version: version.Info{Major:&amp;#34;1&amp;#34;, Minor:&amp;#34;20&amp;#34;, GitVersion:&amp;#34;v1.20.0-k3s1&amp;#34;, GitCommit:&amp;#34;3559625e27197f60bcc39c4b3ecffc80bad7785e&amp;#34;, GitTreeState:&amp;#34;clean&amp;#34;, BuildDate:&amp;#34;2020-12-08T20:42:55Z&amp;#34;, GoVersion:&amp;#34;go1.15.6&amp;#34;, Compiler:&amp;#34;gc&amp;#34;, Platform:&amp;#34;freebsd/amd64&amp;#34;}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So if you take a look above, you&amp;rsquo;ll see that the Server Platform is: &lt;code>&amp;quot;freebsd/amd64&amp;quot;&lt;/code> (I&amp;rsquo;m running as a VM here in my machine!)&lt;/p>
&lt;p>&amp;ldquo;Nah, but this is not enough! I wanna see some Kubernetes Nodes!&amp;rdquo; - Me, talking with myself!&lt;/p>
&lt;p>OK, so let&amp;rsquo;s go. First, you need to install k3s binary on some Linux machine. Go ahead, and grab some &lt;a href="https://github.com/k3s-io/k3s#manual-download">release&lt;/a>&lt;/p>
&lt;p>Nice, so now we need the token to join our agent/node with our Control Plane. It&amp;rsquo;s located on the Control Plane machine, so grab the token with:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>cat /var/lib/rancher/k3s/server/token
&lt;/code>&lt;/pre>&lt;/div>&lt;p>With that token copied, go back to your Linux machine that you&amp;rsquo;re going to run your node/agent and run:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>sudo k3s agent --server https://fbsd-ip:6443 --token THE-TOKEN-YOU-TOOK-NOTE
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After some time, your node will appear for the Control Plane. You can check this way:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>kubectl --kubeconfig=admin.kubeconfig get nodes
&lt;span class="ln">2&lt;/span>NAME STATUS ROLES AGE VERSION
&lt;span class="ln">3&lt;/span>node123 Ready &amp;lt;none&amp;gt; 68m v1.20.0+k3s2
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Go ahead, run some Pods, be happy :D&lt;/p></description></item><item><title>The mix (and mess) of Packet Filter Linux - Part 1</title><link>https://www.rkatz.xyz/post/2020-09-13-the-mix-of-packet-filter-linux-part1/</link><pubDate>Sun, 13 Sep 2020 22:13:56 -0300</pubDate><guid>https://www.rkatz.xyz/post/2020-09-13-the-mix-of-packet-filter-linux-part1/</guid><description>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>So you’ve got a brand new Linux distribution. You start your Kubernetes distributions, and decide for a specific CNI that provides network policies.&lt;/p>
&lt;p>Then you figure out that something is (or is not) working, does an &lt;code>iptables -L&lt;/code> to check what is going on and boom: where are all my iptables rules? Worst of all, you put some newer rules but they seem not to work and your traffic is still being blocked.&lt;/p>
&lt;p>Well, welcome to modern Linux. IPTables is not anymore the only way of doing packet filtering (since a long time, to be honest) and there might be something else blocking it.&lt;/p>
&lt;p>The idea of this article is to show some of those packet filtering technologies, with simple examples and what’s their position during the packet filtering inside the flow.&lt;/p>
&lt;p>&lt;strong>Spoiler alert:&lt;/strong> I’m not really an IPTables/nftables/eBPF specialist (far from that), and the idea here is to study the impact of each one. Feedbacks of this study are more than welcome!&lt;/p>
&lt;h2 id="a-little-bit-of-history">A little bit of history&lt;/h2>
&lt;p>Back in time (before I’ve ever started to work with Linux), kernel 2.2 did already have capabilities of packet filtering with &lt;strong>&lt;a href="https://en.wikipedia.org/wiki/Ipchains">ipchains&lt;/a>&lt;/strong>&lt;/p>
&lt;p>In 1998 it was superseded by &lt;strong>&lt;a href="https://en.wikipedia.org/wiki/Iptables">iptables&lt;/a>&lt;/strong> which has been the de-facto command to make packet filtering in Linux since then.&lt;/p>
&lt;p>And why do I say “command”? Well, Linux is only a kernel composed of features. The packet filtering is done inside the kernel, once the packet arrives in the network card and until it leaves the host. Iptables is the command, in userspace that knows how to say to the kernel “insert this rule that will DROP all the icmp packets”, as an example.&lt;/p>
&lt;p>The same happens in almost everything in Linux. When you issue the “ls” command, ls is a program inside the userspace that will make a &lt;strong>&lt;a href="https://en.wikipedia.org/wiki/System_call">syscall&lt;/a>&lt;/strong> to Linux Kernel, that will then ask for the filesystem which files it have (which turns into another call to the disk, listing it contents).&lt;/p>
&lt;p>So from now one, when we say “iptables” and “nftables”, remember that all of them are just a layer/commands that call the kernel API and put rules into that for the proper packet filtering. By the way, the part of the kernel that deals with packet filtering for both of those programs is called “netfilter” but each one have its special part in the netfilter subsystem.&lt;/p>
&lt;p>I’ll not enter into eBPF behavior right now, as it’s a program that is compiled and runs inside the kernel (not a userspace command). We’ll see more about that in the Part 2 of the article&lt;/p>
&lt;p>Well, going back to history: after iptables, in 2014 &lt;strong>&lt;a href="https://en.wikipedia.org/wiki/Nftables">nftables&lt;/a>&lt;/strong> got merged into the kernel. Now the thing here is that, nftables also uses netfilter, but in a different part of the kernel. So you might have iptables and nftables co-existing, but one does not know about the existence of the other.&lt;/p>
&lt;p>Yes, it happens. A packet might arrive in the nftables part of the netfilter, but never arrive in the iptables part. And we will see that happening in detail.&lt;/p>
&lt;p>In parallel with nftables, a new technology called &lt;strong>&lt;a href="https://ebpf.io/">eBPF&lt;/a>&lt;/strong> was rising in the kernel. But the main idea of eBPF wasn’t to be packet filtering (although the name is Extended Berkeley Packet Filtering) but allow programs to be compiled and attached to the kernel to provide observability, networking and other features.&lt;/p>
&lt;h2 id="methodology">Methodology&lt;/h2>
&lt;p>So for this study, the methodology is going to be quite simple. I’ll install a Linux distribution with Kernel &amp;gt;= 5.4, and make the following tests:&lt;/p>
&lt;ul>
&lt;li>Run a simple tcp port 12345 with netcat to verify the port is open: &lt;code>nc -l -k 12345&lt;/code>&lt;/li>
&lt;li>Create rules to log and drop a packet to TCP port 12345 in each of the netfilter stacks and check the logs to see where is it being dropped.&lt;/li>
&lt;li>Change the rules to accept the packet in each of the netfilter stacks, and check what&amp;rsquo;s the way the packet flows through the logs.&lt;/li>
&lt;li>Make some experiments / inversions both in input and output chains to gather more information about the positioning of each stacks&lt;/li>
&lt;li>Put some eBPF + XDP (in part 2) and check if the package arrives at the netfilter stack&lt;/li>
&lt;li>Make the same test, but now putting eBPF + TC program (again, in part 2)&lt;/li>
&lt;li>Try to join all of this with OVS and check what’s the position of OVS in the above mess :)&lt;/li>
&lt;/ul>
&lt;p>I’m not entering into the packet forwarding flow (the machine acting as a router) in this article, but this can be explored further later (maybe a Part 3?)&lt;/p>
&lt;h2 id="iptables">IPTables&lt;/h2>
&lt;p>So now, let’s go through IPTables with some brief explanation.&lt;/p>
&lt;p>IPTables as the name says is composed by&amp;hellip;tables! Tadah! So, basically you have 4 tables here:&lt;/p>
&lt;ul>
&lt;li>Filter -&amp;gt; deals with packet filtering inside the machine. &lt;strong>We’re going to use this one in this article&lt;/strong>&lt;/li>
&lt;li>Nat -&amp;gt; Deals with packets being routed through the machine.&lt;/li>
&lt;li>Mangle -&amp;gt; Deals with packet behavior changing&lt;/li>
&lt;li>Raw -&amp;gt; this is a special one. Raw table deals with packets before the kernel starts tracking it (see conntrack).&lt;/li>
&lt;/ul>
&lt;p>The below picture shows the packet flowing through iptables:&lt;/p>
&lt;p>&lt;img src="https://www.rkatz.xyz/images/mixpacketfilter/iptables-diagram.png" alt="IPTables flow.">
Original picture from: &lt;a href="https://www.booleanworld.com/depth-guide-iptables-linux-firewall/">https://www.booleanworld.com/depth-guide-iptables-linux-firewall/&lt;/a>&lt;/p>
&lt;p>So, to get started let’s create the simpler log and drop iptables rule. I’ll use the command iptables-legacy to use the old iptables, as the actual “iptables” command points to iptables-nft which inserts the rule into nftables:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>iptables-legacy -A INPUT -p tcp --dport &lt;span class="m">12345&lt;/span> -j LOG --log-level &lt;span class="m">4&lt;/span> --log-prefix ipt-input
&lt;span class="ln">2&lt;/span>iptables-legacy -A INPUT -p tcp --dport &lt;span class="m">12345&lt;/span> -j DROP
&lt;span class="ln">3&lt;/span>iptables-legacy -A OUTPUT -p tcp --sport &lt;span class="m">12345&lt;/span> -j LOG --log-level &lt;span class="m">4&lt;/span> --log-prefix ipt-output
&lt;/code>&lt;/pre>&lt;/div>&lt;p>With the code above, the linux kernel will log, with a level of “Warning” when a packet arrives in tcp port 12345 and drop it. Also when it leaves the machine with source port 12345 it will be logged (for further tests). Assuming the port 12345 is up and listening connections, and the above filter rules has been already created, let’s see what happens in the log. I&amp;rsquo;m wrapping the log here to fit in the code snippet ;)&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="ln">1&lt;/span>&lt;span class="n">Sep&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="m">20&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">34&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">53&lt;/span> &lt;span class="n">fw123&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">[&lt;/span> &lt;span class="m">719.092757&lt;/span>&lt;span class="n">]&lt;/span> &lt;span class="n">ipt&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">input&lt;/span> &lt;span class="n">IN&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">ens33&lt;/span> &lt;span class="n">OUT&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">MAC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">00&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">29&lt;/span> &lt;span class="n">[...]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So the packet arrives into the stack and gots logged. After that, the packet is dropped by the &lt;strong>DROP&lt;/strong> rule.&lt;/p>
&lt;h2 id="adding-nftables-to-the-recipe">Adding NFTables to the recipe&lt;/h2>
&lt;p>As IPTables, NFtables also works with tables. But differently from IPTables, nftables was designed so the chain of rules is much more simpler, so when you got a rule that needs to “log and then drop” the rule is evaluated as once, instead of going through the whole stack. Also iptables deals natively with “ipset”, which allows you to create rules with sets that can be updated dynamically, instead of having the need to change directly a rule (delete a rule, create a newer rule).&lt;/p>
&lt;p>There are some other features that I’m not going to jump in here, but it’s worth reading nftables wiki: &lt;a href="https://wiki.nftables.org/wiki-nftables/index.php/Main_Page">https://wiki.nftables.org/wiki-nftables/index.php/Main_Page&lt;/a> and there’s a nice nftables reference and comparison here: &lt;a href="https://www.slideshare.net/azilian/nftables-the-evolution-of-linux-firewall">https://www.slideshare.net/azilian/nftables-the-evolution-of-linux-firewall&lt;/a>&lt;/p>
&lt;p>So to create nftables rules, we can go through two different ways: using the nft command, that deals natively with the nftables netfilter stack, or using the iptables-nft command, that brings compatibility with iptables command syntax.&lt;/p>
&lt;p>For this test I’ll use the native command and load the following rules:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="ln"> 1&lt;/span>&lt;span class="nx">flush&lt;/span> &lt;span class="nx">ruleset&lt;/span>
&lt;span class="ln"> 2&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="nx">table&lt;/span> &lt;span class="nx">inet&lt;/span> &lt;span class="nx">filter&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="nx">chain&lt;/span> &lt;span class="nx">input&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="nx">type&lt;/span> &lt;span class="nx">filter&lt;/span> &lt;span class="nx">hook&lt;/span> &lt;span class="nx">input&lt;/span> &lt;span class="nx">priority&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="nx">tcp&lt;/span> &lt;span class="nx">dport&lt;/span> &lt;span class="mi">12345&lt;/span> &lt;span class="nx">log&lt;/span> &lt;span class="nx">level&lt;/span> &lt;span class="nx">warn&lt;/span> &lt;span class="nx">prefix&lt;/span> &lt;span class="s2">&amp;#34;nft-input&amp;#34;&lt;/span> &lt;span class="nx">accept&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="nx">chain&lt;/span> &lt;span class="nx">forward&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="nx">type&lt;/span> &lt;span class="nx">filter&lt;/span> &lt;span class="nx">hook&lt;/span> &lt;span class="nx">forward&lt;/span> &lt;span class="nx">priority&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="nx">chain&lt;/span> &lt;span class="nx">output&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="nx">type&lt;/span> &lt;span class="nx">filter&lt;/span> &lt;span class="nx">hook&lt;/span> &lt;span class="nx">output&lt;/span> &lt;span class="nx">priority&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="nx">tcp&lt;/span> &lt;span class="nx">sport&lt;/span> &lt;span class="mi">12345&lt;/span> &lt;span class="nx">log&lt;/span> &lt;span class="nx">level&lt;/span> &lt;span class="nx">warn&lt;/span> &lt;span class="nx">prefix&lt;/span> &lt;span class="s2">&amp;#34;nft-output&amp;#34;&lt;/span> &lt;span class="nx">accept&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">15&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So the rules above will log and accept the package. This way, we can see if it flows first into iptables or nftables. If iptables is in the front, the package will be dropped without any log from nftables. They can be loaded with &lt;code>nft -f file-containing-rules&lt;/code>&lt;/p>
&lt;p>So our scenario now is:&lt;/p>
&lt;ul>
&lt;li>nftables input -&amp;gt; accept&lt;/li>
&lt;li>iptables input -&amp;gt; drop&lt;/li>
&lt;/ul>
&lt;p>And here it is. By the log below, we can see it entering nftables and then iptables. Again, the logs are wrapped to fit into the code snippet:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="ln">1&lt;/span>&lt;span class="n">Sep&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="m">21&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">14&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">26&lt;/span> &lt;span class="n">fw123&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">[&lt;/span> &lt;span class="m">3092.194827&lt;/span>&lt;span class="n">]&lt;/span> &lt;span class="n">nft&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">input&lt;/span> &lt;span class="n">IN&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">ens33&lt;/span> &lt;span class="n">OUT&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">MAC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">00&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">29&lt;/span> &lt;span class="n">[...]&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="n">Sep&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="m">21&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">14&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">26&lt;/span> &lt;span class="n">fw123&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">[&lt;/span> &lt;span class="m">3092.194869&lt;/span>&lt;span class="n">]&lt;/span> &lt;span class="n">ipt&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">input&lt;/span> &lt;span class="n">IN&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">ens33&lt;/span> &lt;span class="n">OUT&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">MAC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">00&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">29&lt;/span> &lt;span class="n">[...]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Let’s change the input scenario to the following:&lt;/p>
&lt;ul>
&lt;li>nftables input -&amp;gt; drop&lt;/li>
&lt;li>iptables input -&amp;gt; drop&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="ln">1&lt;/span>&lt;span class="n">Sep&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="m">21&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">16&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">38&lt;/span> &lt;span class="n">fw123&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">[&lt;/span> &lt;span class="m">3224.260511&lt;/span>&lt;span class="n">]&lt;/span> &lt;span class="n">nft&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">input&lt;/span> &lt;span class="n">IN&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">ens33&lt;/span> &lt;span class="n">OUT&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">MAC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">00&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">29&lt;/span> &lt;span class="n">[...]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>No further iptables log appears!&lt;/strong>. This means that, regarding the iptables and nftables input flow, we can say that nftables has precedence over iptables as the following diagram:&lt;/p>
&lt;p>&lt;img src="https://www.rkatz.xyz/images/mixpacketfilter/input-flow-ipt-nft.png" alt="The input flow.">&lt;/p>
&lt;p>So let’s move to the output scenario. What I want to check is: who is the last mile when a packet is leaving the host? IPTables or NFTables?&lt;/p>
&lt;p>So remember that iptables rules were created to accept the output? So we can change the input rules of both nftables and iptables to log/accept, and then start working in the output rules:&lt;/p>
&lt;ul>
&lt;li>iptables output -&amp;gt; log/drop&lt;/li>
&lt;li>nftables output -&amp;gt; log/accept&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="ln">1&lt;/span>&lt;span class="n">Sep&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="m">21&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">27&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">12&lt;/span> &lt;span class="n">fw123&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">[&lt;/span> &lt;span class="m">3858.172623&lt;/span>&lt;span class="n">]&lt;/span> &lt;span class="n">nft&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">input&lt;/span> &lt;span class="n">IN&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">ens33&lt;/span> &lt;span class="n">OUT&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">MAC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">00&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">29&lt;/span> &lt;span class="n">[...]&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="n">Sep&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="m">21&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">27&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">12&lt;/span> &lt;span class="n">fw123&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">[&lt;/span> &lt;span class="m">3858.172684&lt;/span>&lt;span class="n">]&lt;/span> &lt;span class="n">ipt&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">input&lt;/span> &lt;span class="n">IN&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">ens33&lt;/span> &lt;span class="n">OUT&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">MAC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">00&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">29&lt;/span> &lt;span class="n">[...]&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="n">Sep&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="m">21&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">27&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">12&lt;/span> &lt;span class="n">fw123&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">[&lt;/span> &lt;span class="m">3858.172736&lt;/span>&lt;span class="n">]&lt;/span> &lt;span class="n">nft&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">output&lt;/span> &lt;span class="n">IN&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">OUT&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">ens33&lt;/span> &lt;span class="n">SRC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">192.168.86.128&lt;/span> &lt;span class="n">[...]&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="n">Sep&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="m">21&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">27&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">12&lt;/span> &lt;span class="n">fw123&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">[&lt;/span> &lt;span class="m">3858.172750&lt;/span>&lt;span class="n">]&lt;/span> &lt;span class="n">ipt&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">output&lt;/span> &lt;span class="n">IN&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">OUT&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">ens33&lt;/span> &lt;span class="n">SRC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">192.168.86.128&lt;/span> &lt;span class="n">[...]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So what we can see here is that the packet enters into nftables, then goes to iptables, goes back to nftables and then reaches iptables.&lt;/p>
&lt;p>Can we surely say that iptables is the last mile of the packet processing? Let’s change the rules to:&lt;/p>
&lt;ul>
&lt;li>iptables output -&amp;gt; accept&lt;/li>
&lt;li>nftables output -&amp;gt; drop&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="ln">1&lt;/span>&lt;span class="n">Sep&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="m">21&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">30&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">27&lt;/span> &lt;span class="n">fw123&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">[&lt;/span> &lt;span class="m">4052.554977&lt;/span>&lt;span class="n">]&lt;/span> &lt;span class="n">nft&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">input&lt;/span> &lt;span class="n">IN&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">ens33&lt;/span> &lt;span class="n">OUT&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">MAC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">00&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">29&lt;/span> &lt;span class="n">[...]&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="n">Sep&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="m">21&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">30&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">27&lt;/span> &lt;span class="n">fw123&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">[&lt;/span> &lt;span class="m">4052.555079&lt;/span>&lt;span class="n">]&lt;/span> &lt;span class="n">ipt&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">input&lt;/span> &lt;span class="n">IN&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">ens33&lt;/span> &lt;span class="n">OUT&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">MAC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">00&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">29&lt;/span> &lt;span class="n">[...]&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="n">Sep&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="m">21&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">30&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">27&lt;/span> &lt;span class="n">fw123&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">[&lt;/span> &lt;span class="m">4052.555137&lt;/span>&lt;span class="n">]&lt;/span> &lt;span class="n">nft&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">output&lt;/span> &lt;span class="n">IN&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">OUT&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">ens33&lt;/span> &lt;span class="n">SRC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">192.168.86.128&lt;/span> &lt;span class="n">[...]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So here it is. The packet never reaches the output log rule from iptables. So we can surely say that the following represents a diagram of the packet flowing to outside of the host:&lt;/p>
&lt;p>&lt;img src="https://www.rkatz.xyz/images/mixpacketfilter/output-flow-ipt-nft.png" alt="The output flow.">&lt;/p>
&lt;h2 id="conclusion-so-far">Conclusion (so far)&lt;/h2>
&lt;p>So you got something strange in your environment and don’t know why some traffic is being blocked even if no iptables rule is doing that. As we’ve seen here, nftables rules have precedence over iptables rules.&lt;/p>
&lt;p>If they were created with the compatibility command line tool (iptables-nft) you should first take a look into the output of both commands: &lt;code>iptables-legacy -L&lt;/code> and &lt;code>iptables-nft -L&lt;/code> and try to understand if there are rules in both places, what is inserting those rules there and why.&lt;/p>
&lt;p>Kubernetes, as an example, has a nice wrapper called.. &lt;a href="https://github.com/kubernetes-sigs/iptables-wrappers/">iptables-wrapper&lt;/a> and helps the components that use iptables to decide which one should be used: the legacy one or the compatible one. But remember, as Kubernetes is not aware of how the other parts of the system (aka CNIs) insert the rules, you might have something messing up with things :)&lt;/p>
&lt;p>In the next part of this article I’ll take a look into eBPF and the multiple ways of packet filtering. And also, how they deal with netfilter stack.&lt;/p></description></item></channel></rss>