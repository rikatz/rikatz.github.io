<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kubernetes on The Katz Experiments</title><link>https://www.rkatz.xyz/tags/kubernetes/</link><description>Recent content in Kubernetes on The Katz Experiments</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 30 Dec 2020 17:55:19 -0300</lastBuildDate><atom:link href="https://www.rkatz.xyz/tags/kubernetes/index.xml" rel="self" type="application/rss+xml"/><item><title>Kubernetes Control Plane natively on FreeBSD with K3s</title><link>https://www.rkatz.xyz/post/2020-12-30-k8s-control-plane-fbsd-k3s/</link><pubDate>Wed, 30 Dec 2020 17:55:19 -0300</pubDate><guid>https://www.rkatz.xyz/post/2020-12-30-k8s-control-plane-fbsd-k3s/</guid><description>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>I&amp;rsquo;ve been trying, on the past few days make Kubernetes usable on FreeBSD. Why? Some would say I like to suffer. Others would say I have much spare time.&lt;/p>
&lt;p>To be honest, I&amp;rsquo;m doing this for fun. &lt;a href="https://www.freebsd.org">FreeBSD&lt;/a>, for me, is one of the most stable and performant Operating Systems, and it&amp;rsquo;s sad that we cannot
use it to run Kubernetes components (yet).&lt;/p>
&lt;p>In a near future, me and &lt;a href="twitter.com/fuzzykb">Karen Bruner&lt;/a> are planning to make not only the control plane usable, but also to use one of the precedents of containers on
modern operating systems, even before Docker: &lt;a href="https://www.freebsd.org/doc/handbook/jails.html">Jails&lt;/a> as a &amp;ldquo;container runtime&amp;rdquo;.&lt;/p>
&lt;p>I&amp;rsquo;m also using &lt;a href="https://k3s.io/">k3s&lt;/a> because I became too lazy to configure Kubernetes the hard way :P So bootstrapping an etcd, then the components was too much (for now)
just to have some fun. But maybe some day, will do.&lt;/p>
&lt;p>&lt;strong>Spoiler alert&lt;/strong>: All the main components of Kubernetes can be compiled for FreeBSD. An exception, right now is just &lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/">kubelet&lt;/a>
that have, in a method a wrong syscall to fetch the node boottime, but a &lt;a href="https://github.com/kubernetes/kubernetes/pull/97270">PR&lt;/a> was created to correct that.&lt;/p>
&lt;h2 id="removing-code-before-compiling">Removing code before compiling&lt;/h2>
&lt;p>So K3s is a AIO (all in one) binary that runs all the components necessary to make Kubernetes works. You can use Alex Ellis &lt;a href="https://github.com/alexellis/k3sup">k3sup&lt;/a>
to bootstrap a Kubernetes cluster really, really fast.&lt;/p>
&lt;p>Karen has also shown &lt;a href="https://productionwithscissors.run/2020/12/26/adventures-in-freebernetes-tutorial-build-your-own-bare-vm-k3s-cluster/">how to do this with FreeBSD&lt;/a> as a virtualization host + Linux machines running over bhyve (It&amp;rsquo;s a FreeBSD + bhyve + Linux + k3sup) and you should really check this!&lt;/p>
&lt;p>But going back to the main subject: k3s does not natively compile for FreeBSD. And why this happens? Because it needs some components that can only be compiled on Linux (or Windows) to work.&lt;/p>
&lt;p>As an example, it embeds &lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy&lt;/a>. But, kube-proxy needs &lt;a href="https://en.wikipedia.org/wiki/Iptabl">iptables&lt;/a> and ipvs(&lt;a href="https://en.wikipedia.org/wiki/IP_Virtual_Server">https://en.wikipedia.org/wiki/IP_Virtual_Server&lt;/a>) to compile, which are Linux native technologies, not present on FreeBSD kernel.&lt;/p>
&lt;p>The same happens with &lt;a href="https://github.com/coreos/flannel">flannel&lt;/a>, which is embedded in the code and used as the &lt;a href="https://github.com/containernetworking/cni">CNI&lt;/a>.&lt;/p>
&lt;p>Fortunately, all of this code are present on a main package of k3s: &lt;strong>agent&lt;/strong>. But, we don&amp;rsquo;t need agent for our Control Plane, because agent is responsible for behaving like&amp;hellip;AN AGENT for k3s :D&lt;/p>
&lt;p>So, moving on, you can see the necessary modifications to make k3s compile for FreeBSD here: &lt;a href="https://github.com/k3s-io/k3s/compare/v1.20.0+k3s2...rikatz:fbsd-control-plane">https://github.com/k3s-io/k3s/compare/v1.20.0+k3s2...rikatz:fbsd-control-plane&lt;/a>&lt;/p>
&lt;p>Explaining:&lt;/p>
&lt;ul>
&lt;li>There are some files I hadn&amp;rsquo;t changed, but appear as difference because I&amp;rsquo;ve made all the mods from upstream branch&lt;/li>
&lt;li>On the &lt;code>main.go&lt;/code> files (cmd/k3s/main.go and main.go) the call to &amp;ldquo;agent&amp;rdquo; packages is removed. The resulting binary wont have &amp;ldquo;agent&amp;rdquo; subcommand, but only &amp;ldquo;server&amp;rdquo;, &amp;ldquo;kubectl&amp;rdquo;, etc.&lt;/li>
&lt;li>On &lt;code>pkg/cli/server/server.go&lt;/code> all the references for &lt;code>agent&lt;/code> and &lt;code>rootless&lt;/code> are removed. This way, we are not using anything from &lt;code>agent&lt;/code> package that can stop us from compiling!&lt;/li>
&lt;li>On &lt;code>pkg/daemons/executor&lt;/code> interface, all the references for Kubelet and KubeProxy are removed. We&amp;rsquo;re running control plane, and as both of those components does not compile in FreeBSD, let&amp;rsquo;s get rid of them&lt;/li>
&lt;li>On &lt;code>pkg/server/server.go&lt;/code> all the references for rootless/rootlessports are removed, because this package uses some native Linux calls to make rootless works (and we&amp;rsquo;re not running anything as a container anyway!)&lt;/li>
&lt;/ul>
&lt;p>There&amp;rsquo;s one more item to take note: On &lt;a href="https://github.com/rikatz/k3s/blob/fbsd-control-plane/pkg/cli/server/server.go#L47">server.go&lt;/a> k3s uses an artifact to masquerade its process to not expose some credential passed as an argument.&lt;/p>
&lt;p>But the library used (gspt) uses some headers and some sort of CGO, so you can make two choices here:&lt;/p>
&lt;ul>
&lt;li>Remove the mentioned line (and the referenced library) and be aware someone using ps wwwaux can see your credentials&lt;/li>
&lt;li>Keep the line, but compile on a FreeBSD machine (instead of using GOOS=freebsd on a Linux machine). Also, be aware that &lt;strong>WITH THIS OPTION K3S DOES NOT COMPILE FOR RPI3/ARM64&lt;/strong> (or maybe you need a rpi3 and compile there, which is plausible but I didn&amp;rsquo;t tried!)&lt;/li>
&lt;/ul>
&lt;p>One alternative here (and I need to check if this is possible) is to replace this to some syscall.&lt;/p>
&lt;h2 id="compiling">Compiling&lt;/h2>
&lt;p>So now that all the modifications have been explained, compiling is pretty easy:&lt;/p>
&lt;ul>
&lt;li>If you are on a Linux machine (and removed the gspt line mentioned above)&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>GOOS=freebsd go build -o k3s main.go
&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can put also a GOARCH=arm64 together with GOOS=freebsd and compile it for RPi3&lt;/p>
&lt;ul>
&lt;li>If you are on a FreeBSD machine:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>go build -o k3s main.go
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Aaaand that&amp;rsquo;s it!&lt;/p>
&lt;h2 id="running">Running&lt;/h2>
&lt;p>Well, so here we got a problem. K3s was built to run as a standalone AIO with embedded database (sqlite), or you can use an external database (postgres, mysql, etcd, etc).&lt;/p>
&lt;p>But, it happens that sqlite is built with CGO, and because we don&amp;rsquo;t have it on FreeBSD the best option FOR ME was: install a default Postgres and make it run.&lt;/p>
&lt;p>Here a side note: I didn&amp;rsquo;t put much effort on trying to make sqlite works, and instead I&amp;rsquo;ve directly jumped to Postgres because it was the easiest path. But, be my guest, and tell me what have you discovered!&lt;/p>
&lt;p>Well, so, to make it run we need:&lt;/p>
&lt;ul>
&lt;li>A Postgres DB&lt;/li>
&lt;li>The generated binary&lt;/li>
&lt;/ul>
&lt;p>Installing Postgres on FreeBSD is really, really simple but yes, you can run this on an external DB running on Linux, in some cloud, etc.&lt;/p>
&lt;p>But let&amp;rsquo;s install this DB. Assuming you have a FreeBSD box working:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>pkg update
&lt;span class="ln">2&lt;/span>pkg install postgresql12-server postgresql12-client
&lt;span class="ln">3&lt;/span>sysrc postgresql_enable=yes
&lt;span class="ln">4&lt;/span>/usr/local/etc/rc.d/postgresql initdb
&lt;span class="ln">5&lt;/span>service postgresql start
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And that&amp;rsquo;s it for PostgreSQL. Obviously, this is a VERY INSECURE lab setup! Don&amp;rsquo;t run this (or anything in this tutorial, to be fair) in Production!&lt;/p>
&lt;p>Well, with Postgres up and running, you can run k3s and your control plane will be magically bootstrapped:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>./k3s server --datastore-endpoint=postgres://postgres@127.0.0.1?sslmode=disable
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is going to print a lot of messages in your terminal, and now you have a Kubernetes Control Plane up and running natively on FreeBSD. Nice, right?&lt;/p>
&lt;h2 id="testing">Testing&lt;/h2>
&lt;p>Well, ok, the daemon is running but PROVE ME IT WORKS!&lt;/p>
&lt;p>Okie, so first of all, you need somewhere to run a kubectl. You can run it on FreeBSD (it&amp;rsquo;s easy to compile! I promise!) but I wont go that way right now.&lt;/p>
&lt;p>So, grab the kubeconfig you&amp;rsquo;re going to use on &lt;code>/var/lib/rancher/k3s/server/cred/admin.kubeconfig&lt;/code>, plus the referenced certificates in &lt;code>/var/lib/rancher/k3s/server/tls/client-*&lt;/code> and &lt;code>/var/lib/rancher/k3s/server/tls/server-ca.crt&lt;/code>, and copy them to another machine that kubectl is installed.&lt;/p>
&lt;p>Edit the admin.kubeconfig file, changing:&lt;/p>
&lt;ul>
&lt;li>&lt;code>server: https://127.0.0.1:6444&lt;/code> -&amp;gt; &lt;code>server: https://fbsd-ip:6443&lt;/code>&lt;/li>
&lt;li>&lt;code>certificate-authority&lt;/code>, &lt;code>client-certificate&lt;/code> and &lt;code>client-key&lt;/code> to point to certificates location. If they&amp;rsquo;re on the same directory as admin.kubeconfig, just remove the leading path and leave only the file name&lt;/li>
&lt;/ul>
&lt;p>Great! So now let&amp;rsquo;s check if kubectl can communicate with the server and what it brings to us:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>kubectl --kubeconfig=admin.kubeconfig version
&lt;span class="ln">2&lt;/span>Client Version: version.Info{Major:&amp;#34;1&amp;#34;, Minor:&amp;#34;20&amp;#34;, GitVersion:&amp;#34;v1.20.1&amp;#34;, GitCommit:&amp;#34;c4d752765b3bbac2237bf87cf0b1c2e307844666&amp;#34;, GitTreeState:&amp;#34;clean&amp;#34;, BuildDate:&amp;#34;2020-12-18T12:09:25Z&amp;#34;, GoVersion:&amp;#34;go1.15.5&amp;#34;, Compiler:&amp;#34;gc&amp;#34;, Platform:&amp;#34;linux/amd64&amp;#34;}
&lt;span class="ln">3&lt;/span>Server Version: version.Info{Major:&amp;#34;1&amp;#34;, Minor:&amp;#34;20&amp;#34;, GitVersion:&amp;#34;v1.20.0-k3s1&amp;#34;, GitCommit:&amp;#34;3559625e27197f60bcc39c4b3ecffc80bad7785e&amp;#34;, GitTreeState:&amp;#34;clean&amp;#34;, BuildDate:&amp;#34;2020-12-08T20:42:55Z&amp;#34;, GoVersion:&amp;#34;go1.15.6&amp;#34;, Compiler:&amp;#34;gc&amp;#34;, Platform:&amp;#34;freebsd/amd64&amp;#34;}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So if you take a look above, you&amp;rsquo;ll see that the Server Platform is: &lt;code>&amp;quot;freebsd/amd64&amp;quot;&lt;/code> (I&amp;rsquo;m running as a VM here in my machine!)&lt;/p>
&lt;p>&amp;ldquo;Nah, but this is not enough! I wanna see some Kubernetes Nodes!&amp;rdquo; - Me, talking with myself!&lt;/p>
&lt;p>OK, so let&amp;rsquo;s go. First, you need to install k3s binary on some Linux machine. Go ahead, and grab some &lt;a href="https://github.com/k3s-io/k3s#manual-download">release&lt;/a>&lt;/p>
&lt;p>Nice, so now we need the token to join our agent/node with our Control Plane. It&amp;rsquo;s located on the Control Plane machine, so grab the token with:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>cat /var/lib/rancher/k3s/server/token
&lt;/code>&lt;/pre>&lt;/div>&lt;p>With that token copied, go back to your Linux machine that you&amp;rsquo;re going to run your node/agent and run:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>sudo k3s agent --server https://fbsd-ip:6443 --token THE-TOKEN-YOU-TOOK-NOTE
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After some time, your node will appear for the Control Plane. You can check this way:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="ln">1&lt;/span>kubectl --kubeconfig=admin.kubeconfig get nodes
&lt;span class="ln">2&lt;/span>NAME STATUS ROLES AGE VERSION
&lt;span class="ln">3&lt;/span>node123 Ready &amp;lt;none&amp;gt; 68m v1.20.0+k3s2
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Go ahead, run some Pods, be happy :D&lt;/p></description></item><item><title>The mix (and mess) of Packet Filter Linux - Part 1</title><link>https://www.rkatz.xyz/post/2020-09-13-the-mix-of-packet-filter-linux-part1/</link><pubDate>Sun, 13 Sep 2020 22:13:56 -0300</pubDate><guid>https://www.rkatz.xyz/post/2020-09-13-the-mix-of-packet-filter-linux-part1/</guid><description>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>So you’ve got a brand new Linux distribution. You start your Kubernetes distributions, and decide for a specific CNI that provides network policies.&lt;/p>
&lt;p>Then you figure out that something is (or is not) working, does an &lt;code>iptables -L&lt;/code> to check what is going on and boom: where are all my iptables rules? Worst of all, you put some newer rules but they seem not to work and your traffic is still being blocked.&lt;/p>
&lt;p>Well, welcome to modern Linux. IPTables is not anymore the only way of doing packet filtering (since a long time, to be honest) and there might be something else blocking it.&lt;/p>
&lt;p>The idea of this article is to show some of those packet filtering technologies, with simple examples and what’s their position during the packet filtering inside the flow.&lt;/p>
&lt;p>&lt;strong>Spoiler alert:&lt;/strong> I’m not really an IPTables/nftables/eBPF specialist (far from that), and the idea here is to study the impact of each one. Feedbacks of this study are more than welcome!&lt;/p>
&lt;h2 id="a-little-bit-of-history">A little bit of history&lt;/h2>
&lt;p>Back in time (before I’ve ever started to work with Linux), kernel 2.2 did already have capabilities of packet filtering with &lt;strong>&lt;a href="https://en.wikipedia.org/wiki/Ipchains">ipchains&lt;/a>&lt;/strong>&lt;/p>
&lt;p>In 1998 it was superseded by &lt;strong>&lt;a href="https://en.wikipedia.org/wiki/Iptables">iptables&lt;/a>&lt;/strong> which has been the de-facto command to make packet filtering in Linux since then.&lt;/p>
&lt;p>And why do I say “command”? Well, Linux is only a kernel composed of features. The packet filtering is done inside the kernel, once the packet arrives in the network card and until it leaves the host. Iptables is the command, in userspace that knows how to say to the kernel “insert this rule that will DROP all the icmp packets”, as an example.&lt;/p>
&lt;p>The same happens in almost everything in Linux. When you issue the “ls” command, ls is a program inside the userspace that will make a &lt;strong>&lt;a href="https://en.wikipedia.org/wiki/System_call">syscall&lt;/a>&lt;/strong> to Linux Kernel, that will then ask for the filesystem which files it have (which turns into another call to the disk, listing it contents).&lt;/p>
&lt;p>So from now one, when we say “iptables” and “nftables”, remember that all of them are just a layer/commands that call the kernel API and put rules into that for the proper packet filtering. By the way, the part of the kernel that deals with packet filtering for both of those programs is called “netfilter” but each one have its special part in the netfilter subsystem.&lt;/p>
&lt;p>I’ll not enter into eBPF behavior right now, as it’s a program that is compiled and runs inside the kernel (not a userspace command). We’ll see more about that in the Part 2 of the article&lt;/p>
&lt;p>Well, going back to history: after iptables, in 2014 &lt;strong>&lt;a href="https://en.wikipedia.org/wiki/Nftables">nftables&lt;/a>&lt;/strong> got merged into the kernel. Now the thing here is that, nftables also uses netfilter, but in a different part of the kernel. So you might have iptables and nftables co-existing, but one does not know about the existence of the other.&lt;/p>
&lt;p>Yes, it happens. A packet might arrive in the nftables part of the netfilter, but never arrive in the iptables part. And we will see that happening in detail.&lt;/p>
&lt;p>In parallel with nftables, a new technology called &lt;strong>&lt;a href="https://ebpf.io/">eBPF&lt;/a>&lt;/strong> was rising in the kernel. But the main idea of eBPF wasn’t to be packet filtering (although the name is Extended Berkeley Packet Filtering) but allow programs to be compiled and attached to the kernel to provide observability, networking and other features.&lt;/p>
&lt;h2 id="methodology">Methodology&lt;/h2>
&lt;p>So for this study, the methodology is going to be quite simple. I’ll install a Linux distribution with Kernel &amp;gt;= 5.4, and make the following tests:&lt;/p>
&lt;ul>
&lt;li>Run a simple tcp port 12345 with netcat to verify the port is open: &lt;code>nc -l -k 12345&lt;/code>&lt;/li>
&lt;li>Create rules to log and drop a packet to TCP port 12345 in each of the netfilter stacks and check the logs to see where is it being dropped.&lt;/li>
&lt;li>Change the rules to accept the packet in each of the netfilter stacks, and check what&amp;rsquo;s the way the packet flows through the logs.&lt;/li>
&lt;li>Make some experiments / inversions both in input and output chains to gather more information about the positioning of each stacks&lt;/li>
&lt;li>Put some eBPF + XDP (in part 2) and check if the package arrives at the netfilter stack&lt;/li>
&lt;li>Make the same test, but now putting eBPF + TC program (again, in part 2)&lt;/li>
&lt;li>Try to join all of this with OVS and check what’s the position of OVS in the above mess :)&lt;/li>
&lt;/ul>
&lt;p>I’m not entering into the packet forwarding flow (the machine acting as a router) in this article, but this can be explored further later (maybe a Part 3?)&lt;/p>
&lt;h2 id="iptables">IPTables&lt;/h2>
&lt;p>So now, let’s go through IPTables with some brief explanation.&lt;/p>
&lt;p>IPTables as the name says is composed by&amp;hellip;tables! Tadah! So, basically you have 4 tables here:&lt;/p>
&lt;ul>
&lt;li>Filter -&amp;gt; deals with packet filtering inside the machine. &lt;strong>We’re going to use this one in this article&lt;/strong>&lt;/li>
&lt;li>Nat -&amp;gt; Deals with packets being routed through the machine.&lt;/li>
&lt;li>Mangle -&amp;gt; Deals with packet behavior changing&lt;/li>
&lt;li>Raw -&amp;gt; this is a special one. Raw table deals with packets before the kernel starts tracking it (see conntrack).&lt;/li>
&lt;/ul>
&lt;p>The below picture shows the packet flowing through iptables:&lt;/p>
&lt;p>&lt;img src="https://www.rkatz.xyz/images/mixpacketfilter/iptables-diagram.png" alt="IPTables flow.">
Original picture from: &lt;a href="https://www.booleanworld.com/depth-guide-iptables-linux-firewall/">https://www.booleanworld.com/depth-guide-iptables-linux-firewall/&lt;/a>&lt;/p>
&lt;p>So, to get started let’s create the simpler log and drop iptables rule. I’ll use the command iptables-legacy to use the old iptables, as the actual “iptables” command points to iptables-nft which inserts the rule into nftables:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="ln">1&lt;/span>iptables-legacy -A INPUT -p tcp --dport &lt;span class="m">12345&lt;/span> -j LOG --log-level &lt;span class="m">4&lt;/span> --log-prefix ipt-input
&lt;span class="ln">2&lt;/span>iptables-legacy -A INPUT -p tcp --dport &lt;span class="m">12345&lt;/span> -j DROP
&lt;span class="ln">3&lt;/span>iptables-legacy -A OUTPUT -p tcp --sport &lt;span class="m">12345&lt;/span> -j LOG --log-level &lt;span class="m">4&lt;/span> --log-prefix ipt-output
&lt;/code>&lt;/pre>&lt;/div>&lt;p>With the code above, the linux kernel will log, with a level of “Warning” when a packet arrives in tcp port 12345 and drop it. Also when it leaves the machine with source port 12345 it will be logged (for further tests). Assuming the port 12345 is up and listening connections, and the above filter rules has been already created, let’s see what happens in the log. I&amp;rsquo;m wrapping the log here to fit in the code snippet ;)&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="ln">1&lt;/span>&lt;span class="n">Sep&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="m">20&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">34&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">53&lt;/span> &lt;span class="n">fw123&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">[&lt;/span> &lt;span class="m">719.092757&lt;/span>&lt;span class="n">]&lt;/span> &lt;span class="n">ipt&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">input&lt;/span> &lt;span class="n">IN&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">ens33&lt;/span> &lt;span class="n">OUT&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">MAC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">00&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">29&lt;/span> &lt;span class="n">[...]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So the packet arrives into the stack and gots logged. After that, the packet is dropped by the &lt;strong>DROP&lt;/strong> rule.&lt;/p>
&lt;h2 id="adding-nftables-to-the-recipe">Adding NFTables to the recipe&lt;/h2>
&lt;p>As IPTables, NFtables also works with tables. But differently from IPTables, nftables was designed so the chain of rules is much more simpler, so when you got a rule that needs to “log and then drop” the rule is evaluated as once, instead of going through the whole stack. Also iptables deals natively with “ipset”, which allows you to create rules with sets that can be updated dynamically, instead of having the need to change directly a rule (delete a rule, create a newer rule).&lt;/p>
&lt;p>There are some other features that I’m not going to jump in here, but it’s worth reading nftables wiki: &lt;a href="https://wiki.nftables.org/wiki-nftables/index.php/Main_Page">https://wiki.nftables.org/wiki-nftables/index.php/Main_Page&lt;/a> and there’s a nice nftables reference and comparison here: &lt;a href="https://www.slideshare.net/azilian/nftables-the-evolution-of-linux-firewall">https://www.slideshare.net/azilian/nftables-the-evolution-of-linux-firewall&lt;/a>&lt;/p>
&lt;p>So to create nftables rules, we can go through two different ways: using the nft command, that deals natively with the nftables netfilter stack, or using the iptables-nft command, that brings compatibility with iptables command syntax.&lt;/p>
&lt;p>For this test I’ll use the native command and load the following rules:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="ln"> 1&lt;/span>&lt;span class="nx">flush&lt;/span> &lt;span class="nx">ruleset&lt;/span>
&lt;span class="ln"> 2&lt;/span>
&lt;span class="ln"> 3&lt;/span>&lt;span class="nx">table&lt;/span> &lt;span class="nx">inet&lt;/span> &lt;span class="nx">filter&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 4&lt;/span> &lt;span class="nx">chain&lt;/span> &lt;span class="nx">input&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 5&lt;/span> &lt;span class="nx">type&lt;/span> &lt;span class="nx">filter&lt;/span> &lt;span class="nx">hook&lt;/span> &lt;span class="nx">input&lt;/span> &lt;span class="nx">priority&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln"> 6&lt;/span> &lt;span class="nx">tcp&lt;/span> &lt;span class="nx">dport&lt;/span> &lt;span class="mi">12345&lt;/span> &lt;span class="nx">log&lt;/span> &lt;span class="nx">level&lt;/span> &lt;span class="nx">warn&lt;/span> &lt;span class="nx">prefix&lt;/span> &lt;span class="s2">&amp;#34;nft-input&amp;#34;&lt;/span> &lt;span class="nx">accept&lt;/span>
&lt;span class="ln"> 7&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln"> 8&lt;/span> &lt;span class="nx">chain&lt;/span> &lt;span class="nx">forward&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln"> 9&lt;/span> &lt;span class="nx">type&lt;/span> &lt;span class="nx">filter&lt;/span> &lt;span class="nx">hook&lt;/span> &lt;span class="nx">forward&lt;/span> &lt;span class="nx">priority&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">10&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">11&lt;/span> &lt;span class="nx">chain&lt;/span> &lt;span class="nx">output&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="ln">12&lt;/span> &lt;span class="nx">type&lt;/span> &lt;span class="nx">filter&lt;/span> &lt;span class="nx">hook&lt;/span> &lt;span class="nx">output&lt;/span> &lt;span class="nx">priority&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="ln">13&lt;/span> &lt;span class="nx">tcp&lt;/span> &lt;span class="nx">sport&lt;/span> &lt;span class="mi">12345&lt;/span> &lt;span class="nx">log&lt;/span> &lt;span class="nx">level&lt;/span> &lt;span class="nx">warn&lt;/span> &lt;span class="nx">prefix&lt;/span> &lt;span class="s2">&amp;#34;nft-output&amp;#34;&lt;/span> &lt;span class="nx">accept&lt;/span>
&lt;span class="ln">14&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="ln">15&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So the rules above will log and accept the package. This way, we can see if it flows first into iptables or nftables. If iptables is in the front, the package will be dropped without any log from nftables. They can be loaded with &lt;code>nft -f file-containing-rules&lt;/code>&lt;/p>
&lt;p>So our scenario now is:&lt;/p>
&lt;ul>
&lt;li>nftables input -&amp;gt; accept&lt;/li>
&lt;li>iptables input -&amp;gt; drop&lt;/li>
&lt;/ul>
&lt;p>And here it is. By the log below, we can see it entering nftables and then iptables. Again, the logs are wrapped to fit into the code snippet:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="ln">1&lt;/span>&lt;span class="n">Sep&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="m">21&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">14&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">26&lt;/span> &lt;span class="n">fw123&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">[&lt;/span> &lt;span class="m">3092.194827&lt;/span>&lt;span class="n">]&lt;/span> &lt;span class="n">nft&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">input&lt;/span> &lt;span class="n">IN&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">ens33&lt;/span> &lt;span class="n">OUT&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">MAC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">00&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">29&lt;/span> &lt;span class="n">[...]&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="n">Sep&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="m">21&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">14&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">26&lt;/span> &lt;span class="n">fw123&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">[&lt;/span> &lt;span class="m">3092.194869&lt;/span>&lt;span class="n">]&lt;/span> &lt;span class="n">ipt&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">input&lt;/span> &lt;span class="n">IN&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">ens33&lt;/span> &lt;span class="n">OUT&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">MAC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">00&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">29&lt;/span> &lt;span class="n">[...]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Let’s change the input scenario to the following:&lt;/p>
&lt;ul>
&lt;li>nftables input -&amp;gt; drop&lt;/li>
&lt;li>iptables input -&amp;gt; drop&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="ln">1&lt;/span>&lt;span class="n">Sep&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="m">21&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">16&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">38&lt;/span> &lt;span class="n">fw123&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">[&lt;/span> &lt;span class="m">3224.260511&lt;/span>&lt;span class="n">]&lt;/span> &lt;span class="n">nft&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">input&lt;/span> &lt;span class="n">IN&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">ens33&lt;/span> &lt;span class="n">OUT&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">MAC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">00&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">29&lt;/span> &lt;span class="n">[...]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>No further iptables log appears!&lt;/strong>. This means that, regarding the iptables and nftables input flow, we can say that nftables has precedence over iptables as the following diagram:&lt;/p>
&lt;p>&lt;img src="https://www.rkatz.xyz/images/mixpacketfilter/input-flow-ipt-nft.png" alt="The input flow.">&lt;/p>
&lt;p>So let’s move to the output scenario. What I want to check is: who is the last mile when a packet is leaving the host? IPTables or NFTables?&lt;/p>
&lt;p>So remember that iptables rules were created to accept the output? So we can change the input rules of both nftables and iptables to log/accept, and then start working in the output rules:&lt;/p>
&lt;ul>
&lt;li>iptables output -&amp;gt; log/drop&lt;/li>
&lt;li>nftables output -&amp;gt; log/accept&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="ln">1&lt;/span>&lt;span class="n">Sep&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="m">21&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">27&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">12&lt;/span> &lt;span class="n">fw123&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">[&lt;/span> &lt;span class="m">3858.172623&lt;/span>&lt;span class="n">]&lt;/span> &lt;span class="n">nft&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">input&lt;/span> &lt;span class="n">IN&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">ens33&lt;/span> &lt;span class="n">OUT&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">MAC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">00&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">29&lt;/span> &lt;span class="n">[...]&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="n">Sep&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="m">21&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">27&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">12&lt;/span> &lt;span class="n">fw123&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">[&lt;/span> &lt;span class="m">3858.172684&lt;/span>&lt;span class="n">]&lt;/span> &lt;span class="n">ipt&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">input&lt;/span> &lt;span class="n">IN&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">ens33&lt;/span> &lt;span class="n">OUT&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">MAC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">00&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">29&lt;/span> &lt;span class="n">[...]&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="n">Sep&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="m">21&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">27&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">12&lt;/span> &lt;span class="n">fw123&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">[&lt;/span> &lt;span class="m">3858.172736&lt;/span>&lt;span class="n">]&lt;/span> &lt;span class="n">nft&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">output&lt;/span> &lt;span class="n">IN&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">OUT&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">ens33&lt;/span> &lt;span class="n">SRC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">192.168.86.128&lt;/span> &lt;span class="n">[...]&lt;/span>
&lt;span class="ln">4&lt;/span>&lt;span class="n">Sep&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="m">21&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">27&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">12&lt;/span> &lt;span class="n">fw123&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">[&lt;/span> &lt;span class="m">3858.172750&lt;/span>&lt;span class="n">]&lt;/span> &lt;span class="n">ipt&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">output&lt;/span> &lt;span class="n">IN&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">OUT&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">ens33&lt;/span> &lt;span class="n">SRC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">192.168.86.128&lt;/span> &lt;span class="n">[...]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So what we can see here is that the packet enters into nftables, then goes to iptables, goes back to nftables and then reaches iptables.&lt;/p>
&lt;p>Can we surely say that iptables is the last mile of the packet processing? Let’s change the rules to:&lt;/p>
&lt;ul>
&lt;li>iptables output -&amp;gt; accept&lt;/li>
&lt;li>nftables output -&amp;gt; drop&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="ln">1&lt;/span>&lt;span class="n">Sep&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="m">21&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">30&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">27&lt;/span> &lt;span class="n">fw123&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">[&lt;/span> &lt;span class="m">4052.554977&lt;/span>&lt;span class="n">]&lt;/span> &lt;span class="n">nft&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">input&lt;/span> &lt;span class="n">IN&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">ens33&lt;/span> &lt;span class="n">OUT&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">MAC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">00&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">29&lt;/span> &lt;span class="n">[...]&lt;/span>
&lt;span class="ln">2&lt;/span>&lt;span class="n">Sep&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="m">21&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">30&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">27&lt;/span> &lt;span class="n">fw123&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">[&lt;/span> &lt;span class="m">4052.555079&lt;/span>&lt;span class="n">]&lt;/span> &lt;span class="n">ipt&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">input&lt;/span> &lt;span class="n">IN&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">ens33&lt;/span> &lt;span class="n">OUT&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">MAC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">00&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">29&lt;/span> &lt;span class="n">[...]&lt;/span>
&lt;span class="ln">3&lt;/span>&lt;span class="n">Sep&lt;/span> &lt;span class="m">13&lt;/span> &lt;span class="m">21&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">30&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="m">27&lt;/span> &lt;span class="n">fw123&lt;/span> &lt;span class="n">kernel&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">[&lt;/span> &lt;span class="m">4052.555137&lt;/span>&lt;span class="n">]&lt;/span> &lt;span class="n">nft&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">output&lt;/span> &lt;span class="n">IN&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">OUT&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">ens33&lt;/span> &lt;span class="n">SRC&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">192.168.86.128&lt;/span> &lt;span class="n">[...]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So here it is. The packet never reaches the output log rule from iptables. So we can surely say that the following represents a diagram of the packet flowing to outside of the host:&lt;/p>
&lt;p>&lt;img src="https://www.rkatz.xyz/images/mixpacketfilter/output-flow-ipt-nft.png" alt="The output flow.">&lt;/p>
&lt;h2 id="conclusion-so-far">Conclusion (so far)&lt;/h2>
&lt;p>So you got something strange in your environment and don’t know why some traffic is being blocked even if no iptables rule is doing that. As we’ve seen here, nftables rules have precedence over iptables rules.&lt;/p>
&lt;p>If they were created with the compatibility command line tool (iptables-nft) you should first take a look into the output of both commands: &lt;code>iptables-legacy -L&lt;/code> and &lt;code>iptables-nft -L&lt;/code> and try to understand if there are rules in both places, what is inserting those rules there and why.&lt;/p>
&lt;p>Kubernetes, as an example, has a nice wrapper called.. &lt;a href="https://github.com/kubernetes-sigs/iptables-wrappers/">iptables-wrapper&lt;/a> and helps the components that use iptables to decide which one should be used: the legacy one or the compatible one. But remember, as Kubernetes is not aware of how the other parts of the system (aka CNIs) insert the rules, you might have something messing up with things :)&lt;/p>
&lt;p>In the next part of this article I’ll take a look into eBPF and the multiple ways of packet filtering. And also, how they deal with netfilter stack.&lt;/p></description></item></channel></rss>